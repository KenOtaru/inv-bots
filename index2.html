<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Digit Differ Trading Bot</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @keyframes pulse-green {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
            }

            50% {
                box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
            }
        }

        @keyframes pulse-red {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
            }

            50% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
        }

        .pulse-green {
            animation: pulse-green 2s infinite;
        }

        .pulse-red {
            animation: pulse-red 2s infinite;
        }

        .digit-box {
            transition: all 0.3s ease;
        }

        .digit-box:hover {
            transform: scale(1.1);
        }

        .digit-hot {
            background: linear-gradient(135deg, #f97316, #dc2626);
        }

        .digit-cold {
            background: linear-gradient(135deg, #3b82f6, #6366f1);
        }

        .digit-neutral {
            background: linear-gradient(135deg, #374151, #1f2937);
        }

        .glass {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }

        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar-thin::-webkit-scrollbar-track {
            background: #1f2937;
        }

        .scrollbar-thin::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 3px;
        }

        .trade-win {
            border-left: 4px solid #22c55e;
        }

        .trade-loss {
            border-left: 4px solid #ef4444;
        }
    </style>
</head>

<body class="bg-gray-900 text-white min-h-screen">
    <!-- Header -->
    <header class="bg-gray-800 border-b border-gray-700 px-6 py-4">
        <div class="flex items-center justify-between max-w-7xl mx-auto">
            <div class="flex items-center gap-3">
                <div class="text-3xl">üé≤</div>
                <div>
                    <h1
                        class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                        Enhanced Digit Differ Bot
                    </h1>
                    <p class="text-xs text-gray-400">AI-Powered Trading System v2.0</p>
                </div>
            </div>
            <div class="flex items-center gap-4">
                <div id="connectionStatus" class="flex items-center gap-2 px-3 py-1 rounded-full bg-gray-700">
                    <div id="statusDot" class="w-2 h-2 rounded-full bg-gray-500"></div>
                    <span id="statusText" class="text-sm">Disconnected</span>
                </div>
                <div id="balanceDisplay" class="text-lg font-semibold text-green-400">$0.00</div>
            </div>
        </div>
    </header>

    <main class="max-w-7xl mx-auto p-6">
        <!-- Control Panel -->
        <div class="glass rounded-xl p-6 mb-6 border border-gray-700">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-1">API Token</label>
                    <input type="password" id="apiToken" placeholder="Enter Deriv API Token"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Asset</label>
                    <select id="assetSelect"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                        <option value="R_10">Volatility 10 Index</option>
                        <option value="R_25">Volatility 25 Index</option>
                        <option value="R_50" selected>Volatility 50 Index</option>
                        <option value="R_75">Volatility 75 Index</option>
                        <option value="R_100">Volatility 100 Index</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Stake ($)</label>
                    <input type="number" id="stakeInput" value="1" min="0.35" step="0.01"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Tick Duration</label>
                    <select id="durationSelect"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                        <option value="1" selected>1 Tick</option>
                        <option value="2">2 Ticks</option>
                        <option value="3">3 Ticks</option>
                        <option value="5">5 Ticks</option>
                    </select>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Stop Loss ($)</label>
                    <input type="number" id="stopLoss" value="10" min="1"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Take Profit ($)</label>
                    <input type="number" id="takeProfit" value="5" min="1"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Min Confidence</label>
                    <input type="number" id="minConfidence" value="0.12" min="0.05" max="0.5" step="0.01"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Martingale Multiplier</label>
                    <input type="number" id="martingaleMultiplier" value="2.2" min="1.1" max="10" step="0.1"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mt-4">
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Martingale Steps</label>
                    <input type="number" id="martingaleSteps" value="5" min="1" max="20" step="1"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Reset After Max Steps</label>
                    <select id="resetAfterMax"
                        class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 focus:border-blue-500 focus:outline-none">
                        <option value="reset" selected>Reset to Initial Stake</option>
                        <option value="stop">Stop Trading</option>
                        <option value="continue">Continue (No Reset)</option>
                    </select>
                </div>
                <div class="flex items-end">
                    <div class="w-full bg-gray-800 border border-gray-600 rounded-lg px-4 py-2">
                        <div class="text-xs text-gray-400">Martingale Step</div>
                        <div class="flex items-center gap-2">
                            <span id="currentMartingaleStep" class="text-lg font-bold text-yellow-400">0</span>
                            <span class="text-gray-500">/</span>
                            <span id="maxMartingaleSteps" class="text-gray-400">5</span>
                        </div>
                    </div>
                </div>
                <div class="flex items-end gap-2">
                    <button id="startBtn" onclick="toggleBot()"
                        class="flex-1 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-semibold py-2 px-6 rounded-lg transition-all">
                        ‚ñ∂ Start Bot
                    </button>
                    <button onclick="saveSettings()"
                        class="bg-blue-600 hover:bg-blue-500 text-white py-2 px-3 rounded-lg transition-all"
                        title="Save Settings">
                        üíæ
                    </button>
                    <button onclick="loadSettings()"
                        class="bg-purple-600 hover:bg-purple-500 text-white py-2 px-3 rounded-lg transition-all"
                        title="Load Settings">
                        üìÇ
                    </button>
                    <button onclick="clearData()"
                        class="bg-gray-700 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-all"
                        title="Clear Learning Data">
                        üóëÔ∏è
                    </button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Column: Live Digits & Predictions -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Live Tick Display -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-lg font-semibold flex items-center gap-2">
                            <span>üìä</span> Live Market Data
                        </h2>
                        <div id="lastPrice" class="text-xl font-mono text-blue-400">--</div>
                    </div>

                    <!-- Last 20 Digits -->
                    <div class="mb-4">
                        <div class="text-sm text-gray-400 mb-2">Last 20 Digits</div>
                        <div id="recentDigits" class="flex flex-wrap gap-2">
                            <!-- Digits will be populated here -->
                        </div>
                    </div>

                    <!-- Digit Frequency Distribution -->
                    <div>
                        <div class="text-sm text-gray-400 mb-2">Digit Distribution (Hot üî• / Cold ‚ùÑÔ∏è)</div>
                        <div class="grid grid-cols-10 gap-2" id="digitDistribution">
                            <!-- Distribution bars will be here -->
                        </div>
                    </div>
                </div>

                <!-- AI Prediction Panel -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <h2 class="text-lg font-semibold flex items-center gap-2 mb-4">
                        <span>üß†</span> AI Prediction Engine
                    </h2>

                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                        <div class="bg-gray-800 rounded-lg p-4 text-center">
                            <div class="text-sm text-gray-400">Statistical</div>
                            <div id="statPrediction" class="text-2xl font-bold text-orange-400">-</div>
                            <div id="statConfidence" class="text-xs text-gray-500">--% conf</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 text-center">
                            <div class="text-sm text-gray-400">Pattern</div>
                            <div id="patternPrediction" class="text-2xl font-bold text-purple-400">-</div>
                            <div id="patternConfidence" class="text-xs text-gray-500">--% conf</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 text-center">
                            <div class="text-sm text-gray-400">Neural Net</div>
                            <div id="neuralPrediction" class="text-2xl font-bold text-blue-400">-</div>
                            <div id="neuralConfidence" class="text-xs text-gray-500">--% conf</div>
                        </div>
                        <div class="bg-gray-800 rounded-lg p-4 text-center border-2 border-yellow-500">
                            <div class="text-sm text-yellow-400">Ensemble</div>
                            <div id="ensemblePrediction" class="text-2xl font-bold text-yellow-400">-</div>
                            <div id="ensembleConfidence" class="text-xs text-gray-500">--% conf</div>
                        </div>
                    </div>

                    <!-- Prediction Bars -->
                    <div class="space-y-2">
                        <div class="text-sm text-gray-400">Digit Probability Scores</div>
                        <div id="predictionBars" class="space-y-1">
                            <!-- Prediction bars for each digit -->
                        </div>
                    </div>
                </div>

                <!-- Trade History -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-lg font-semibold flex items-center gap-2">
                            <span>üìú</span> Trade History
                        </h2>
                        <div class="text-sm text-gray-400">
                            Last <span id="tradeCount">0</span> trades
                        </div>
                    </div>
                    <div id="tradeHistory" class="space-y-2 max-h-64 overflow-y-auto scrollbar-thin">
                        <div class="text-gray-500 text-center py-4">No trades yet</div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Stats & Learning -->
            <div class="space-y-6">
                <!-- Performance Stats -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <h2 class="text-lg font-semibold flex items-center gap-2 mb-4">
                        <span>üìà</span> Performance
                    </h2>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Total Trades</span>
                            <span id="totalTrades" class="text-xl font-bold">0</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Win Rate</span>
                            <span id="winRate" class="text-xl font-bold text-green-400">0%</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Wins / Losses</span>
                            <span>
                                <span id="totalWins" class="text-green-400 font-bold">0</span>
                                <span class="text-gray-500">/</span>
                                <span id="totalLosses" class="text-red-400 font-bold">0</span>
                            </span>
                        </div>
                        <div class="border-t border-gray-700 pt-4">
                            <div class="flex justify-between items-center">
                                <span class="text-gray-400">Profit / Loss</span>
                                <span id="totalPnL" class="text-2xl font-bold">$0.00</span>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Current Stake</span>
                            <span id="currentStake" class="font-bold text-yellow-400">$1.00</span>
                        </div>
                    </div>
                </div>

                <!-- Learning Metrics -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <h2 class="text-lg font-semibold flex items-center gap-2 mb-4">
                        <span>üéì</span> Learning Status
                    </h2>
                    <div class="space-y-3">
                        <div>
                            <div class="flex justify-between text-sm mb-1">
                                <span class="text-gray-400">Observations</span>
                                <span id="observations">0 / 50</span>
                            </div>
                            <div class="w-full bg-gray-700 rounded-full h-2">
                                <div id="learningProgress" class="bg-blue-500 h-2 rounded-full transition-all"
                                    style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Mode</span>
                            <span id="learningMode"
                                class="px-2 py-1 rounded text-xs bg-yellow-500/20 text-yellow-400">Learning</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Market Entropy</span>
                            <span id="marketEntropy" class="font-mono">--</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Neural Accuracy</span>
                            <span id="neuralAccuracy" class="font-mono">--</span>
                        </div>
                    </div>
                </div>

                <!-- Model Weights -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <h2 class="text-lg font-semibold flex items-center gap-2 mb-4">
                        <span>‚öñÔ∏è</span> Model Weights
                    </h2>
                    <div class="space-y-3" id="modelWeights">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Statistical</span>
                            <div class="flex items-center gap-2">
                                <div class="w-20 bg-gray-700 rounded-full h-2">
                                    <div class="bg-orange-500 h-2 rounded-full" style="width: 30%"></div>
                                </div>
                                <span class="text-sm">30%</span>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Pattern</span>
                            <div class="flex items-center gap-2">
                                <div class="w-20 bg-gray-700 rounded-full h-2">
                                    <div class="bg-purple-500 h-2 rounded-full" style="width: 25%"></div>
                                </div>
                                <span class="text-sm">25%</span>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Neural</span>
                            <div class="flex items-center gap-2">
                                <div class="w-20 bg-gray-700 rounded-full h-2">
                                    <div class="bg-blue-500 h-2 rounded-full" style="width: 25%"></div>
                                </div>
                                <span class="text-sm">25%</span>
                            </div>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-400">Streak</span>
                            <div class="flex items-center gap-2">
                                <div class="w-20 bg-gray-700 rounded-full h-2">
                                    <div class="bg-green-500 h-2 rounded-full" style="width: 20%"></div>
                                </div>
                                <span class="text-sm">20%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Activity Log -->
                <div class="glass rounded-xl p-6 border border-gray-700">
                    <h2 class="text-lg font-semibold flex items-center gap-2 mb-4">
                        <span>üìã</span> Activity Log
                    </h2>
                    <div id="activityLog" class="space-y-2 max-h-48 overflow-y-auto scrollbar-thin text-sm">
                        <div class="text-gray-500">Waiting to start...</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="text-center py-4 text-gray-500 text-sm">
        Enhanced Digit Differ Bot v2.0 | AI-Powered Trading System
    </footer>

    <script>
        // ============================================================================
        // TIER 1: DIGIT STATISTICAL ENGINE
        // ============================================================================
        class DigitStatisticalEngine {
            constructor() {
                this.digitFrequencies = {};
                this.bayesianPriors = {};
                this.chiSquareScores = {};
                this.entropyScores = {};
                this.expectedFrequency = 0.1;
            }

            initAsset(asset) {
                this.digitFrequencies[asset] = {
                    counts: Array(10).fill(0),
                    total: 0,
                    recentCounts: Array(10).fill(0),
                    recentTotal: 0
                };
                this.bayesianPriors[asset] = Array(10).fill(null).map(() => ({ alpha: 1, beta: 9 }));
                this.chiSquareScores[asset] = Array(10).fill(0);
            }

            updateFrequency(asset, digit) {
                if (!this.digitFrequencies[asset]) {
                    this.initAsset(asset);
                }

                const freq = this.digitFrequencies[asset];
                freq.counts[digit]++;
                freq.total++;
                freq.recentCounts[digit]++;
                freq.recentTotal++;

                if (freq.recentTotal > 100) {
                    for (let i = 0; i < 10; i++) {
                        freq.recentCounts[i] = Math.floor(freq.recentCounts[i] * 0.99);
                    }
                    freq.recentTotal = freq.recentCounts.reduce((a, b) => a + b, 0);
                }

                this.updateBayesian(asset, digit);
                this.calculateChiSquare(asset);
            }

            getDigitProbabilities(asset, useRecent = true) {
                if (!this.digitFrequencies[asset]) {
                    return Array(10).fill(0.1);
                }

                const freq = this.digitFrequencies[asset];
                const counts = useRecent ? freq.recentCounts : freq.counts;
                const total = useRecent ? freq.recentTotal : freq.total;

                if (total === 0) {
                    return Array(10).fill(0.1);
                }

                return counts.map(c => c / total);
            }

            updateBayesian(asset, observedDigit) {
                if (!this.bayesianPriors[asset]) {
                    this.bayesianPriors[asset] = Array(10).fill(null).map(() => ({ alpha: 1, beta: 9 }));
                }

                this.bayesianPriors[asset][observedDigit].alpha += 1;

                for (let i = 0; i < 10; i++) {
                    if (i !== observedDigit) {
                        this.bayesianPriors[asset][i].beta += 1;
                    }
                }

                const decay = 0.999;
                for (let i = 0; i < 10; i++) {
                    this.bayesianPriors[asset][i].alpha = Math.max(1, this.bayesianPriors[asset][i].alpha * decay);
                    this.bayesianPriors[asset][i].beta = Math.max(1, this.bayesianPriors[asset][i].beta * decay);
                }
            }

            getBayesianEstimates(asset) {
                if (!this.bayesianPriors[asset]) {
                    return Array(10).fill({ mean: 0.1, variance: 0.01, confidence: 0 });
                }

                return this.bayesianPriors[asset].map(prior => {
                    const { alpha, beta } = prior;
                    const mean = alpha / (alpha + beta);
                    const variance = (alpha * beta) / ((alpha + beta) ** 2 * (alpha + beta + 1));
                    const confidence = alpha + beta;

                    return { mean, variance, confidence };
                });
            }

            calculateChiSquare(asset) {
                if (!this.digitFrequencies[asset]) return;

                const freq = this.digitFrequencies[asset];
                if (freq.recentTotal < 30) return;

                const expected = freq.recentTotal * this.expectedFrequency;

                for (let i = 0; i < 10; i++) {
                    const observed = freq.recentCounts[i];
                    const chiSq = Math.pow(observed - expected, 2) / expected;
                    const direction = observed > expected ? 1 : -1;
                    this.chiSquareScores[asset][i] = chiSq * direction;
                }
            }

            getHotDigits(asset, threshold = 2.0) {
                if (!this.chiSquareScores[asset]) return [];

                return this.chiSquareScores[asset]
                    .map((score, digit) => ({ digit, score }))
                    .filter(d => d.score > threshold)
                    .sort((a, b) => b.score - a.score)
                    .map(d => d.digit);
            }

            getColdDigits(asset, threshold = -2.0) {
                if (!this.chiSquareScores[asset]) return [];

                return this.chiSquareScores[asset]
                    .map((score, digit) => ({ digit, score }))
                    .filter(d => d.score < threshold)
                    .sort((a, b) => a.score - b.score)
                    .map(d => d.digit);
            }

            calculateEntropy(asset) {
                const probs = this.getDigitProbabilities(asset, true);

                let entropy = 0;
                probs.forEach(p => {
                    if (p > 0) {
                        entropy -= p * Math.log2(p);
                    }
                });

                const normalizedEntropy = entropy / Math.log2(10);
                this.entropyScores[asset] = normalizedEntropy;

                return normalizedEntropy;
            }

            getBestDigitToDiffer(asset) {
                const probs = this.getDigitProbabilities(asset, true);
                const bayesian = this.getBayesianEstimates(asset);
                const hotDigits = this.getHotDigits(asset);

                const scores = [];
                for (let digit = 0; digit < 10; digit++) {
                    let score = 0;
                    score += probs[digit] * 40;
                    score += bayesian[digit].mean * 30;

                    if (hotDigits.includes(digit)) {
                        score += 20;
                    }

                    const confidence = Math.min(1, bayesian[digit].confidence / 100);
                    score *= (0.5 + 0.5 * confidence);

                    scores.push({ digit, score, prob: probs[digit], bayesian: bayesian[digit].mean });
                }

                scores.sort((a, b) => b.score - a.score);
                return scores;
            }

            exportState() {
                return {
                    digitFrequencies: this.digitFrequencies,
                    bayesianPriors: this.bayesianPriors,
                    chiSquareScores: this.chiSquareScores,
                    entropyScores: this.entropyScores
                };
            }

            importState(state) {
                if (state.digitFrequencies) this.digitFrequencies = state.digitFrequencies;
                if (state.bayesianPriors) this.bayesianPriors = state.bayesianPriors;
                if (state.chiSquareScores) this.chiSquareScores = state.chiSquareScores;
                if (state.entropyScores) this.entropyScores = state.entropyScores;
            }
        }

        // ============================================================================
        // TIER 2: DIGIT PATTERN ENGINE
        // ============================================================================
        class DigitPatternEngine {
            constructor() {
                this.transitionMatrices = {};
                this.ngramModels = {};
                this.streakTrackers = {};
                this.sequenceBuffers = {};
            }

            initAsset(asset) {
                this.transitionMatrices[asset] = {
                    first: Array(10).fill(null).map(() => Array(10).fill(0)),
                    second: {},
                    totals: Array(10).fill(0)
                };
                this.ngramModels[asset] = {};
                this.streakTrackers[asset] = { currentDigit: null, streakLength: 0, history: [] };
                this.sequenceBuffers[asset] = [];
            }

            updatePatterns(asset, digit) {
                if (!this.transitionMatrices[asset]) {
                    this.initAsset(asset);
                }

                const buffer = this.sequenceBuffers[asset];

                if (buffer.length >= 1) {
                    const prevDigit = buffer[buffer.length - 1];
                    this.transitionMatrices[asset].first[prevDigit][digit]++;
                    this.transitionMatrices[asset].totals[prevDigit]++;
                }

                if (buffer.length >= 2) {
                    const key = `${buffer[buffer.length - 2]},${buffer[buffer.length - 1]}`;
                    if (!this.transitionMatrices[asset].second[key]) {
                        this.transitionMatrices[asset].second[key] = Array(10).fill(0);
                    }
                    this.transitionMatrices[asset].second[key][digit]++;
                }

                this.updateNgrams(asset, digit);
                this.updateStreak(asset, digit);

                buffer.push(digit);
                if (buffer.length > 100) {
                    buffer.shift();
                }
            }

            updateNgrams(asset, digit) {
                const buffer = this.sequenceBuffers[asset];
                if (!this.ngramModels[asset]) {
                    this.ngramModels[asset] = {};
                }

                for (let n = 2; n <= 5; n++) {
                    if (buffer.length >= n - 1) {
                        const context = buffer.slice(-(n - 1)).join(',');
                        const key = `${n}:${context}`;

                        if (!this.ngramModels[asset][key]) {
                            this.ngramModels[asset][key] = Array(10).fill(0);
                        }
                        this.ngramModels[asset][key][digit]++;
                    }
                }
            }

            updateStreak(asset, digit) {
                const tracker = this.streakTrackers[asset];

                if (digit === tracker.currentDigit) {
                    tracker.streakLength++;
                } else {
                    if (tracker.currentDigit !== null && tracker.streakLength > 1) {
                        tracker.history.push({
                            digit: tracker.currentDigit,
                            length: tracker.streakLength
                        });
                        if (tracker.history.length > 100) {
                            tracker.history.shift();
                        }
                    }
                    tracker.currentDigit = digit;
                    tracker.streakLength = 1;
                }
            }

            getTransitionProbabilities(asset, currentDigit, order = 1) {
                if (!this.transitionMatrices[asset]) {
                    return Array(10).fill(0.1);
                }

                if (order === 1) {
                    const total = this.transitionMatrices[asset].totals[currentDigit];
                    if (total === 0) return Array(10).fill(0.1);
                    return this.transitionMatrices[asset].first[currentDigit].map(c => c / total);
                }

                const buffer = this.sequenceBuffers[asset];
                if (buffer.length < 1) return Array(10).fill(0.1);

                const key = `${buffer[buffer.length - 1]},${currentDigit}`;
                const counts = this.transitionMatrices[asset].second[key];

                if (!counts) return Array(10).fill(0.1);

                const total = counts.reduce((a, b) => a + b, 0);
                if (total === 0) return Array(10).fill(0.1);

                return counts.map(c => c / total);
            }

            predictFromNgrams(asset, n = 3) {
                const buffer = this.sequenceBuffers[asset];
                if (!this.ngramModels[asset] || buffer.length < n - 1) {
                    return null;
                }

                const context = buffer.slice(-(n - 1)).join(',');
                const key = `${n}:${context}`;
                const counts = this.ngramModels[asset][key];

                if (!counts) return null;

                const total = counts.reduce((a, b) => a + b, 0);
                if (total < 5) return null;

                const probs = counts.map(c => c / total);
                const maxProb = Math.max(...probs);
                const predictedDigit = probs.indexOf(maxProb);

                return {
                    probabilities: probs,
                    predictedDigit,
                    confidence: maxProb,
                    samples: total
                };
            }

            isDigitStreaking(asset, digit) {
                const tracker = this.streakTrackers[asset];
                return tracker && tracker.currentDigit === digit && tracker.streakLength >= 2;
            }

            predictNextDigits(asset) {
                const buffer = this.sequenceBuffers[asset];
                if (!buffer || buffer.length === 0) return null;

                const currentDigit = buffer[buffer.length - 1];

                const firstOrder = this.getTransitionProbabilities(asset, currentDigit, 1);
                const secondOrder = this.getTransitionProbabilities(asset, currentDigit, 2);
                const ngram3 = this.predictFromNgrams(asset, 3);
                const ngram4 = this.predictFromNgrams(asset, 4);

                const combined = Array(10).fill(0);
                const weights = { first: 0.2, second: 0.3, ngram3: 0.3, ngram4: 0.2 };

                for (let i = 0; i < 10; i++) {
                    combined[i] += firstOrder[i] * weights.first;
                    combined[i] += secondOrder[i] * weights.second;

                    if (ngram3) {
                        combined[i] += ngram3.probabilities[i] * weights.ngram3;
                    } else {
                        combined[i] += 0.1 * weights.ngram3;
                    }

                    if (ngram4) {
                        combined[i] += ngram4.probabilities[i] * weights.ngram4;
                    } else {
                        combined[i] += 0.1 * weights.ngram4;
                    }
                }

                const sum = combined.reduce((a, b) => a + b, 0);
                const normalized = combined.map(p => p / sum);

                return {
                    probabilities: normalized,
                    mostLikely: normalized.indexOf(Math.max(...normalized)),
                    leastLikely: normalized.indexOf(Math.min(...normalized))
                };
            }

            exportState() {
                return {
                    transitionMatrices: this.transitionMatrices,
                    ngramModels: this.ngramModels,
                    streakTrackers: this.streakTrackers,
                    sequenceBuffers: this.sequenceBuffers
                };
            }

            importState(state) {
                if (state.transitionMatrices) this.transitionMatrices = state.transitionMatrices;
                if (state.ngramModels) this.ngramModels = state.ngramModels;
                if (state.streakTrackers) this.streakTrackers = state.streakTrackers;
                if (state.sequenceBuffers) this.sequenceBuffers = state.sequenceBuffers;
            }
        }

        // ============================================================================
        // TIER 3: NEURAL NETWORK DIGIT PREDICTOR
        // ============================================================================
        class DigitNeuralEngine {
            constructor(inputSize = 50, hiddenSizes = [64, 32], outputSize = 10) {
                this.inputSize = inputSize;
                this.hiddenSizes = hiddenSizes;
                this.outputSize = outputSize;
                this.learningRate = 0.01;
                this.momentum = 0.9;
                this.weights = {};
                this.biases = {};
                this.velocities = {};
                this.trainingHistory = [];
                this.initialized = false;

                this.initializeNetwork();
            }

            initializeNetwork() {
                const layers = [this.inputSize, ...this.hiddenSizes, this.outputSize];

                for (let i = 0; i < layers.length - 1; i++) {
                    const fanIn = layers[i];
                    const fanOut = layers[i + 1];
                    const scale = Math.sqrt(2.0 / (fanIn + fanOut));

                    this.weights[i] = [];
                    this.velocities[`w${i}`] = [];

                    for (let j = 0; j < fanOut; j++) {
                        this.weights[i][j] = [];
                        this.velocities[`w${i}`][j] = [];

                        for (let k = 0; k < fanIn; k++) {
                            this.weights[i][j][k] = (Math.random() * 2 - 1) * scale;
                            this.velocities[`w${i}`][j][k] = 0;
                        }
                    }

                    this.biases[i] = new Array(fanOut).fill(0).map(() => (Math.random() * 2 - 1) * 0.1);
                    this.velocities[`b${i}`] = new Array(fanOut).fill(0);
                }

                this.initialized = true;
            }

            relu(x) {
                return Math.max(0, x);
            }

            reluDerivative(x) {
                return x > 0 ? 1 : 0;
            }

            softmax(arr) {
                const maxVal = Math.max(...arr);
                const exps = arr.map(x => Math.exp(x - maxVal));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(e => e / sum);
            }

            forward(input) {
                if (input.length !== this.inputSize) {
                    return { output: Array(10).fill(0.1), activations: [] };
                }

                const activations = [input];
                let current = input;

                const numLayers = Object.keys(this.weights).length;

                for (let i = 0; i < numLayers; i++) {
                    const nextLayer = [];

                    for (let j = 0; j < this.weights[i].length; j++) {
                        let sum = this.biases[i][j];

                        for (let k = 0; k < current.length; k++) {
                            sum += current[k] * this.weights[i][j][k];
                        }

                        if (i < numLayers - 1) {
                            nextLayer.push(this.relu(sum));
                        } else {
                            nextLayer.push(sum);
                        }
                    }

                    current = nextLayer;
                    activations.push(current);
                }

                const output = this.softmax(current);

                return { output, activations, rawOutput: current };
            }

            trainOnSample(input, targetDigit) {
                const { output, activations } = this.forward(input);

                const outputGradient = [...output];
                outputGradient[targetDigit] -= 1;

                const numLayers = Object.keys(this.weights).length;
                let delta = outputGradient;

                for (let i = numLayers - 1; i >= 0; i--) {
                    const prevActivation = activations[i];
                    const newDelta = [];

                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            const grad = delta[j] * prevActivation[k];
                            this.velocities[`w${i}`][j][k] =
                                this.momentum * this.velocities[`w${i}`][j][k] - this.learningRate * grad;
                            this.weights[i][j][k] += this.velocities[`w${i}`][j][k];
                        }

                        this.velocities[`b${i}`][j] =
                            this.momentum * this.velocities[`b${i}`][j] - this.learningRate * delta[j];
                        this.biases[i][j] += this.velocities[`b${i}`][j];
                    }

                    if (i > 0) {
                        for (let k = 0; k < this.weights[i][0].length; k++) {
                            let sum = 0;
                            for (let j = 0; j < this.weights[i].length; j++) {
                                sum += delta[j] * this.weights[i][j][k];
                            }
                            newDelta.push(sum * this.reluDerivative(prevActivation[k]));
                        }
                        delta = newDelta;
                    }
                }

                const loss = -Math.log(Math.max(output[targetDigit], 1e-10));

                this.trainingHistory.push({
                    loss,
                    predicted: output.indexOf(Math.max(...output)),
                    actual: targetDigit,
                    correct: output.indexOf(Math.max(...output)) === targetDigit
                });

                if (this.trainingHistory.length > 1000) {
                    this.trainingHistory.shift();
                }

                return { loss, predicted: output.indexOf(Math.max(...output)) };
            }

            predict(input) {
                const { output } = this.forward(input);
                return output;
            }

            prepareFeatures(digitSequence, digitFrequencies) {
                const features = [];

                const recent = digitSequence.slice(-30);
                while (recent.length < 30) recent.unshift(5);
                recent.forEach(d => features.push(d / 9));

                if (digitFrequencies && digitFrequencies.length === 10) {
                    digitFrequencies.forEach(f => features.push(f));
                } else {
                    for (let i = 0; i < 10; i++) features.push(0.1);
                }

                const last3 = digitSequence.slice(-3);
                while (last3.length < 3) last3.unshift(5);
                last3.forEach(d => features.push(d / 9));

                let streakLength = 1;
                for (let i = digitSequence.length - 2; i >= 0 && digitSequence[i] === digitSequence[digitSequence.length - 1]; i--) {
                    streakLength++;
                }
                features.push(Math.min(streakLength, 10) / 10);

                while (features.length < this.inputSize) {
                    features.push(0.5);
                }

                return features.slice(0, this.inputSize);
            }

            getPerformanceMetrics() {
                if (this.trainingHistory.length < 10) {
                    return { accuracy: 0, recentLoss: 1, trend: 'insufficient_data' };
                }

                const recent = this.trainingHistory.slice(-100);
                const avgLoss = recent.reduce((a, b) => a + b.loss, 0) / recent.length;
                const correct = recent.filter(h => h.correct).length;
                const accuracy = correct / recent.length;

                const firstHalf = recent.slice(0, Math.floor(recent.length / 2));
                const secondHalf = recent.slice(Math.floor(recent.length / 2));
                const firstLoss = firstHalf.reduce((a, b) => a + b.loss, 0) / firstHalf.length;
                const secondLoss = secondHalf.reduce((a, b) => a + b.loss, 0) / secondHalf.length;

                const trend = secondLoss < firstLoss * 0.9 ? 'improving' :
                    secondLoss > firstLoss * 1.1 ? 'degrading' : 'stable';

                return { accuracy, recentLoss: avgLoss, trend };
            }

            exportWeights() {
                return {
                    weights: this.weights,
                    biases: this.biases,
                    velocities: this.velocities,
                    trainingHistory: this.trainingHistory.slice(-500)
                };
            }

            importWeights(state) {
                if (state.weights) this.weights = state.weights;
                if (state.biases) this.biases = state.biases;
                if (state.velocities) this.velocities = state.velocities;
                if (state.trainingHistory) this.trainingHistory = state.trainingHistory;
                this.initialized = true;
            }
        }

        // ============================================================================
        // TIER 4: ENSEMBLE DIGIT DECISION MAKER
        // ============================================================================
        class DigitEnsembleDecisionMaker {
            constructor() {
                this.modelWeights = {
                    statistical: 0.30,
                    pattern: 0.25,
                    neural: 0.25,
                    streak: 0.20
                };

                this.modelPerformance = {
                    statistical: { correct: 0, total: 0 },
                    pattern: { correct: 0, total: 0 },
                    neural: { correct: 0, total: 0 },
                    streak: { correct: 0, total: 0 }
                };

                this.recentDecisions = [];
                this.confidenceThreshold = 0.12;
            }

            selectDigitToDiffer(predictions) {
                const combinedScores = Array(10).fill(0);
                const details = {};

                if (predictions.statistical) {
                    const scores = predictions.statistical;
                    for (let i = 0; i < 10; i++) {
                        const scoreItem = scores.find(s => s.digit === i);
                        if (scoreItem) {
                            combinedScores[i] += scoreItem.score * this.modelWeights.statistical;
                        }
                    }
                    details.statistical = scores.slice(0, 3).map(s => `${s.digit}:${s.score.toFixed(1)}`).join(', ');
                }

                if (predictions.pattern && predictions.pattern.probabilities) {
                    for (let i = 0; i < 10; i++) {
                        combinedScores[i] += predictions.pattern.probabilities[i] * 100 * this.modelWeights.pattern;
                    }
                    details.pattern = `Most likely: ${predictions.pattern.mostLikely}`;
                }

                if (predictions.neural) {
                    for (let i = 0; i < 10; i++) {
                        combinedScores[i] += predictions.neural[i] * 100 * this.modelWeights.neural;
                    }
                    const maxNeural = predictions.neural.indexOf(Math.max(...predictions.neural));
                    details.neural = `Predicted: ${maxNeural} (${(predictions.neural[maxNeural] * 100).toFixed(1)}%)`;
                }

                if (predictions.streak) {
                    for (let i = 0; i < 10; i++) {
                        if (predictions.streak.streaking === i) {
                            combinedScores[i] += 15 * this.modelWeights.streak;
                        }
                    }
                    details.streak = predictions.streak.streaking !== null ?
                        `Streaking: ${predictions.streak.streaking}` : 'No streak';
                }

                const ranked = combinedScores
                    .map((score, digit) => ({ digit, score }))
                    .sort((a, b) => b.score - a.score);

                const bestDigit = ranked[0].digit;
                const secondBest = ranked[1].digit;

                // Calculate confidence - normalized to 0-1 range
                const totalScore = combinedScores.reduce((a, b) => a + b, 0);
                const avgScore = totalScore / 10;
                const minScore = Math.min(...combinedScores);
                const maxScore = Math.max(...combinedScores);

                // Use normalized confidence: how much better is best vs average, capped at 1.0
                // Formula: (best - avg) / (max_possible_deviation)
                // Where max_possible_deviation = avg (when best could be 2x avg at most in normal cases)
                let confidence = 0;
                if (avgScore > 0) {
                    // Normalize: (best - avg) / avg, then apply sigmoid-like clamping
                    const rawConfidence = (ranked[0].score - avgScore) / avgScore;
                    // Apply soft clamping using tanh-like function to keep in 0-1 range
                    confidence = Math.min(1, Math.max(0, rawConfidence / (1 + Math.abs(rawConfidence)) + 0.5));
                }

                // Alternative: use score spread as confidence
                const scoreSpread = maxScore - minScore;
                const spreadConfidence = totalScore > 0 ? Math.min(1, scoreSpread / (totalScore * 0.3)) : 0;

                // Blend both confidence measures
                const finalConfidence = Math.min(1, (confidence + spreadConfidence) / 2);

                const bestProbability = totalScore > 0 ? ranked[0].score / totalScore : 0.1;

                return {
                    digitToDiffer: bestDigit,
                    alternativeDigit: secondBest,
                    scores: ranked,
                    confidence: finalConfidence,
                    probability: bestProbability,
                    shouldTrade: finalConfidence > this.confidenceThreshold,
                    details
                };
            }

            recordOutcome(predictions, chosenDigit, actualDigit, won) {
                Object.entries(predictions).forEach(([model, pred]) => {
                    if (!pred) return;

                    let modelPredicted;
                    if (model === 'statistical' && Array.isArray(pred)) {
                        modelPredicted = pred[0]?.digit;
                    } else if (model === 'pattern' && pred.mostLikely !== undefined) {
                        modelPredicted = pred.mostLikely;
                    } else if (model === 'neural' && Array.isArray(pred)) {
                        modelPredicted = pred.indexOf(Math.max(...pred));
                    } else if (model === 'streak' && pred.streaking !== null) {
                        modelPredicted = pred.streaking;
                    }

                    if (modelPredicted !== undefined) {
                        this.modelPerformance[model].total++;
                        if (modelPredicted === actualDigit) {
                            this.modelPerformance[model].correct++;
                        }
                    }
                });

                this.updateModelWeights();

                this.recentDecisions.push({
                    predictions,
                    chosenDigit,
                    actualDigit,
                    won,
                    timestamp: Date.now()
                });

                if (this.recentDecisions.length > 500) {
                    this.recentDecisions.shift();
                }
            }

            updateModelWeights() {
                const minSamples = 20;
                let totalAccuracy = 0;
                const accuracies = {};

                Object.entries(this.modelPerformance).forEach(([model, perf]) => {
                    if (perf.total >= minSamples) {
                        const accuracy = perf.correct / perf.total;
                        accuracies[model] = accuracy;
                        totalAccuracy += accuracy;
                    }
                });

                if (totalAccuracy > 0 && Object.keys(accuracies).length > 0) {
                    Object.entries(accuracies).forEach(([model, accuracy]) => {
                        this.modelWeights[model] = Math.pow(accuracy + 0.1, 2);
                    });

                    const sum = Object.values(this.modelWeights).reduce((a, b) => a + b, 0);
                    Object.keys(this.modelWeights).forEach(model => {
                        this.modelWeights[model] /= sum;
                    });
                }
            }

            getPerformanceSummary() {
                const summary = {};

                Object.entries(this.modelPerformance).forEach(([model, perf]) => {
                    summary[model] = {
                        accuracy: perf.total > 0 ? (perf.correct / perf.total * 100).toFixed(1) + '%' : 'N/A',
                        samples: perf.total,
                        weight: (this.modelWeights[model] * 100).toFixed(1) + '%'
                    };
                });

                return {
                    models: summary,
                    confidenceThreshold: this.confidenceThreshold.toFixed(3),
                    totalDecisions: this.recentDecisions.length
                };
            }

            exportState() {
                return {
                    modelWeights: this.modelWeights,
                    modelPerformance: this.modelPerformance,
                    confidenceThreshold: this.confidenceThreshold,
                    recentDecisions: this.recentDecisions.slice(-200)
                };
            }

            importState(state) {
                if (state.modelWeights) this.modelWeights = state.modelWeights;
                if (state.modelPerformance) this.modelPerformance = state.modelPerformance;
                if (state.confidenceThreshold) this.confidenceThreshold = state.confidenceThreshold;
                if (state.recentDecisions) this.recentDecisions = state.recentDecisions;
            }
        }

        // ============================================================================
        // MAIN BOT CLASS
        // ============================================================================
        class DigitDifferBot {
            constructor() {
                this.ws = null;
                this.connected = false;
                this.isRunning = false;
                this.token = '';
                this.asset = 'R_50';

                // Trading State
                this.currentStake = 1;
                this.initialStake = 1;
                this.totalTrades = 0;
                this.totalWins = 0;
                this.totalLosses = 0;
                this.totalPnL = 0;
                this.consecutiveLosses = 0;
                this.tradeInProgress = false;
                this.balance = 0;

                // Martingale State
                this.martingaleStep = 0;
                this.martingaleHistory = [];

                // Config
                this.config = {
                    stopLoss: 10,
                    takeProfit: 5,
                    tickDuration: 1,
                    minConfidence: 0.12,
                    multiplier: 2.2,
                    martingaleSteps: 5,
                    resetAfterMax: 'reset',
                    learningThreshold: 50
                };

                // Data
                this.tickHistory = [];
                this.tradeHistory = [];
                this.lastPredictions = {};
                this.selectedDigit = null;
                this.currentProposalId = null;

                // Learning Engines
                this.statisticalEngine = new DigitStatisticalEngine();
                this.patternEngine = new DigitPatternEngine();
                this.neuralEngine = new DigitNeuralEngine(50, [64, 32], 10);
                this.ensembleDecisionMaker = new DigitEnsembleDecisionMaker();

                // Learning state
                this.observationCount = 0;
                this.learningMode = true;

                // Load saved state
                this.loadState();
            }

            connect() {
                if (this.ws) {
                    this.ws.close();
                }

                this.log('Connecting to Deriv API...');
                this.ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');

                this.ws.onopen = () => {
                    this.connected = true;
                    this.updateConnectionStatus(true);
                    this.log('Connected to Deriv API');
                    this.authenticate();
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };

                this.ws.onerror = (error) => {
                    this.log('WebSocket error', 'error');
                    console.error(error);
                };

                this.ws.onclose = () => {
                    this.connected = false;
                    this.updateConnectionStatus(false);
                    this.log('Disconnected from Deriv API');

                    if (this.isRunning) {
                        setTimeout(() => this.connect(), 5000);
                    }
                };
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
            }

            send(request) {
                if (this.connected && this.ws) {
                    this.ws.send(JSON.stringify(request));
                }
            }

            authenticate() {
                this.send({ authorize: this.token });
            }

            handleMessage(message) {
                switch (message.msg_type) {
                    case 'authorize':
                        if (message.error) {
                            this.log('Authentication failed: ' + message.error.message, 'error');
                            this.stop();
                            return;
                        }
                        this.log('Authentication successful');
                        this.balance = parseFloat(message.authorize.balance);
                        this.updateBalance();
                        this.subscribeToTicks();
                        break;

                    case 'tick':
                        this.handleTick(message.tick);
                        break;

                    case 'proposal':
                        this.handleProposal(message);
                        break;

                    case 'buy':
                        if (message.error) {
                            this.log('Trade error: ' + message.error.message, 'error');
                            this.tradeInProgress = false;
                            return;
                        }
                        this.log('Trade placed successfully');
                        this.subscribeToContract(message.buy.contract_id);
                        break;

                    case 'proposal_open_contract':
                        this.handleContractUpdate(message.proposal_open_contract);
                        break;

                    case 'balance':
                        this.balance = parseFloat(message.balance.balance);
                        this.updateBalance();
                        break;
                }
            }

            subscribeToTicks() {
                this.send({
                    ticks: this.asset,
                    subscribe: 1
                });
                this.send({
                    balance: 1,
                    subscribe: 1
                });
                this.log(`Subscribed to ${this.asset} ticks`);
            }

            handleTick(tick) {
                const digit = this.getLastDigit(tick.quote);

                this.tickHistory.push(digit);
                if (this.tickHistory.length > 200) {
                    this.tickHistory.shift();
                }

                // Update learning engines
                this.statisticalEngine.updateFrequency(this.asset, digit);
                this.patternEngine.updatePatterns(this.asset, digit);
                this.observationCount++;

                // Train neural network
                if (this.observationCount % 5 === 0) {
                    const features = this.neuralEngine.prepareFeatures(
                        this.tickHistory,
                        this.statisticalEngine.getDigitProbabilities(this.asset)
                    );
                    this.neuralEngine.trainOnSample(features, digit);
                }

                // Update UI
                this.updateUI(tick, digit);

                // Check learning mode
                if (this.learningMode && this.observationCount < this.config.learningThreshold) {
                    this.updateLearningProgress();
                    return;
                } else if (this.learningMode) {
                    this.learningMode = false;
                    this.log('Learning phase complete. Trading enabled!', 'success');
                    document.getElementById('learningMode').textContent = 'Trading';
                    document.getElementById('learningMode').className = 'px-2 py-1 rounded text-xs bg-green-500/20 text-green-400';
                }

                // Analyze and trade
                if (this.isRunning && !this.tradeInProgress) {
                    this.analyzeAndTrade();
                }
            }

            getLastDigit(quote) {
                const quoteString = quote.toString();
                const [, fractionalPart = ''] = quoteString.split('.');

                if (['R_75', 'R_50'].includes(this.asset)) {
                    return fractionalPart.length >= 4 ? parseInt(fractionalPart[3]) : 0;
                } else if (['R_10', 'R_25'].includes(this.asset)) {
                    return fractionalPart.length >= 3 ? parseInt(fractionalPart[2]) : 0;
                } else {
                    return fractionalPart.length >= 2 ? parseInt(fractionalPart[1]) : 0;
                }
            }

            analyzeAndTrade() {
                if (this.tickHistory.length < 30) return;

                const predictions = this.getEnsemblePredictions();
                const decision = this.ensembleDecisionMaker.selectDigitToDiffer(predictions);

                this.lastPredictions = predictions;
                this.updatePredictionUI(predictions, decision);

                if (decision.shouldTrade) {
                    this.selectedDigit = decision.digitToDiffer;
                    this.log(`Trade signal: Differ from ${decision.digitToDiffer} (conf: ${(decision.confidence * 100).toFixed(1)}%)`);
                    this.requestProposal();
                }
            }

            getEnsemblePredictions() {
                const predictions = {};

                predictions.statistical = this.statisticalEngine.getBestDigitToDiffer(this.asset);
                predictions.pattern = this.patternEngine.predictNextDigits(this.asset);

                if (this.neuralEngine.initialized) {
                    const features = this.neuralEngine.prepareFeatures(
                        this.tickHistory,
                        this.statisticalEngine.getDigitProbabilities(this.asset)
                    );
                    predictions.neural = this.neuralEngine.predict(features);
                }

                const lastDigit = this.tickHistory[this.tickHistory.length - 1];
                predictions.streak = {
                    streaking: this.patternEngine.isDigitStreaking(this.asset, lastDigit) ? lastDigit : null
                };

                return predictions;
            }

            requestProposal() {
                this.send({
                    proposal: 1,
                    amount: this.currentStake.toFixed(2),
                    basis: 'stake',
                    contract_type: 'DIGITDIFF',
                    currency: 'USD',
                    symbol: this.asset,
                    duration: this.config.tickDuration,
                    duration_unit: 't',
                    barrier: this.selectedDigit
                });
            }

            handleProposal(message) {
                if (message.error) {
                    this.log('Proposal error: ' + message.error.message, 'error');
                    return;
                }

                if (message.proposal && !this.tradeInProgress) {
                    this.currentProposalId = message.proposal.id;
                    this.placeTrade();
                }
            }

            placeTrade() {
                if (this.tradeInProgress || !this.currentProposalId) return;

                this.send({
                    buy: this.currentProposalId,
                    price: this.currentStake.toFixed(2)
                });

                this.tradeInProgress = true;
                this.log(`Placing trade: Differ from ${this.selectedDigit}, Stake: $${this.currentStake.toFixed(2)}`);
            }

            subscribeToContract(contractId) {
                this.send({
                    proposal_open_contract: 1,
                    contract_id: contractId,
                    subscribe: 1
                });
            }

            handleContractUpdate(contract) {
                if (!contract.is_sold) return;

                const won = contract.status === 'won';
                const profit = parseFloat(contract.profit);
                const exitSpot = contract.exit_tick_display_value;
                const actualDigit = this.getLastDigit(parseFloat(exitSpot));

                this.tradeInProgress = false;
                this.totalTrades++;

                if (won) {
                    this.totalWins++;
                    this.consecutiveLosses = 0;
                    this.martingaleStep = 0;
                    this.currentStake = this.initialStake;
                    this.log(`‚úÖ WON: +${profit.toFixed(2)} (Digit: ${actualDigit}) | Martingale reset`, 'success');
                } else {
                    this.totalLosses++;
                    this.consecutiveLosses++;
                    this.martingaleStep++;

                    // Record martingale history
                    this.martingaleHistory.push({
                        step: this.martingaleStep,
                        stake: this.currentStake,
                        loss: Math.abs(profit),
                        timestamp: Date.now()
                    });

                    // Check if max martingale steps reached
                    if (this.martingaleStep >= this.config.martingaleSteps) {
                        this.log(`‚ö†Ô∏è Max martingale steps (${this.config.martingaleSteps}) reached!`, 'warning');

                        switch (this.config.resetAfterMax) {
                            case 'stop':
                                this.log('Stopping bot due to max martingale steps.', 'error');
                                this.totalPnL += profit;
                                this.updateStats();
                                this.saveState();
                                this.stop();
                                return;
                            case 'reset':
                                this.martingaleStep = 0;
                                this.currentStake = this.initialStake;
                                this.log(`Martingale reset to initial stake: ${this.initialStake.toFixed(2)}`, 'warning');
                                break;
                            case 'continue':
                                // Continue with the same multiplied stake
                                this.currentStake = this.currentStake * this.config.multiplier;
                                this.log(`Continuing with stake: ${this.currentStake.toFixed(2)}`, 'warning');
                                break;
                        }
                    } else {
                        // Apply martingale multiplier
                        this.currentStake = this.currentStake * this.config.multiplier;
                    }

                    this.log(`‚ùå LOST: -${Math.abs(profit).toFixed(2)} (Digit: ${actualDigit}) | Step ${this.martingaleStep}/${this.config.martingaleSteps} | Next: ${this.currentStake.toFixed(2)}`, 'error');
                }

                this.totalPnL += profit;

                // Record outcome for learning
                this.ensembleDecisionMaker.recordOutcome(
                    this.lastPredictions,
                    this.selectedDigit,
                    actualDigit,
                    won
                );

                // Add to trade history
                this.addTradeToHistory(won, profit, this.selectedDigit, actualDigit);

                // Update UI
                this.updateStats();
                this.updateMartingaleUI();
                this.updateModelWeightsUI();

                // Save state
                this.saveState();

                // Check stop conditions
                if (this.totalPnL <= -this.config.stopLoss) {
                    this.log('Stop loss reached. Stopping bot.', 'error');
                    this.stop();
                    return;
                }

                if (this.totalPnL >= this.config.takeProfit) {
                    this.log('Take profit reached. Stopping bot.', 'success');
                    this.stop();
                    return;
                }
            }

            updateMartingaleUI() {
                document.getElementById('currentMartingaleStep').textContent = this.martingaleStep;
                document.getElementById('maxMartingaleSteps').textContent = this.config.martingaleSteps;

                // Color code based on step
                const stepEl = document.getElementById('currentMartingaleStep');
                if (this.martingaleStep === 0) {
                    stepEl.className = 'text-lg font-bold text-green-400';
                } else if (this.martingaleStep < this.config.martingaleSteps / 2) {
                    stepEl.className = 'text-lg font-bold text-yellow-400';
                } else if (this.martingaleStep < this.config.martingaleSteps) {
                    stepEl.className = 'text-lg font-bold text-orange-400';
                } else {
                    stepEl.className = 'text-lg font-bold text-red-400';
                }
            }

            // UI Update Methods
            updateUI(tick, digit) {
                document.getElementById('lastPrice').textContent = tick.quote;

                // Update recent digits
                const recentDigits = this.tickHistory.slice(-20);
                const recentDigitsContainer = document.getElementById('recentDigits');
                recentDigitsContainer.innerHTML = recentDigits.map((d, i) => {
                    const isLatest = i === recentDigits.length - 1;
                    return `<div class="digit-box w-8 h-8 flex items-center justify-center rounded ${isLatest ? 'bg-blue-500 ring-2 ring-blue-300' : 'bg-gray-700'} font-mono font-bold">${d}</div>`;
                }).join('');

                // Update digit distribution
                this.updateDigitDistribution();
            }

            updateDigitDistribution() {
                const probs = this.statisticalEngine.getDigitProbabilities(this.asset, true);
                const hotDigits = this.statisticalEngine.getHotDigits(this.asset);
                const coldDigits = this.statisticalEngine.getColdDigits(this.asset);

                const container = document.getElementById('digitDistribution');
                container.innerHTML = probs.map((prob, digit) => {
                    const height = Math.max(20, prob * 400);
                    let colorClass = 'digit-neutral';
                    let icon = '';

                    if (hotDigits.includes(digit)) {
                        colorClass = 'digit-hot';
                        icon = 'üî•';
                    } else if (coldDigits.includes(digit)) {
                        colorClass = 'digit-cold';
                        icon = '‚ùÑÔ∏è';
                    }

                    return `
                    <div class="flex flex-col items-center">
                        <div class="text-xs mb-1">${icon}</div>
                        <div class="w-full ${colorClass} rounded-t transition-all" style="height: ${height}px"></div>
                        <div class="text-xs mt-1 font-mono">${digit}</div>
                        <div class="text-xs text-gray-500">${(prob * 100).toFixed(0)}%</div>
                    </div>
                `;
                }).join('');
            }

            updatePredictionUI(predictions, decision) {
                // Statistical
                if (predictions.statistical && predictions.statistical[0]) {
                    document.getElementById('statPrediction').textContent = predictions.statistical[0].digit;
                    document.getElementById('statConfidence').textContent = `${(predictions.statistical[0].prob * 100).toFixed(0)}% prob`;
                }

                // Pattern
                if (predictions.pattern) {
                    document.getElementById('patternPrediction').textContent = predictions.pattern.mostLikely;
                    const conf = predictions.pattern.probabilities[predictions.pattern.mostLikely];
                    document.getElementById('patternConfidence').textContent = `${(conf * 100).toFixed(0)}% conf`;
                }

                // Neural
                if (predictions.neural) {
                    const maxIdx = predictions.neural.indexOf(Math.max(...predictions.neural));
                    document.getElementById('neuralPrediction').textContent = maxIdx;
                    document.getElementById('neuralConfidence').textContent = `${(predictions.neural[maxIdx] * 100).toFixed(0)}% conf`;
                }

                // Ensemble
                document.getElementById('ensemblePrediction').textContent = decision.digitToDiffer;
                document.getElementById('ensembleConfidence').textContent = `${(decision.confidence * 100).toFixed(0)}% conf`;

                // Update prediction bars
                this.updatePredictionBars(decision.scores);
            }

            updatePredictionBars(scores) {
                const container = document.getElementById('predictionBars');
                const maxScore = Math.max(...scores.map(s => s.score));

                container.innerHTML = scores.slice(0, 5).map(({ digit, score }) => {
                    const width = (score / maxScore) * 100;
                    const isTop = digit === scores[0].digit;
                    return `
                    <div class="flex items-center gap-2">
                        <div class="w-6 text-center font-mono ${isTop ? 'text-yellow-400 font-bold' : ''}">${digit}</div>
                        <div class="flex-1 bg-gray-700 rounded-full h-3">
                            <div class="h-3 rounded-full transition-all ${isTop ? 'bg-yellow-500' : 'bg-blue-500'}" style="width: ${width}%"></div>
                        </div>
                        <div class="w-12 text-right text-xs text-gray-400">${score.toFixed(1)}</div>
                    </div>
                `;
                }).join('');
            }

            updateLearningProgress() {
                const progress = (this.observationCount / this.config.learningThreshold) * 100;
                document.getElementById('learningProgress').style.width = `${progress}%`;
                document.getElementById('observations').textContent = `${this.observationCount} / ${this.config.learningThreshold}`;
            }

            updateStats() {
                document.getElementById('totalTrades').textContent = this.totalTrades;
                document.getElementById('totalWins').textContent = this.totalWins;
                document.getElementById('totalLosses').textContent = this.totalLosses;

                const winRate = this.totalTrades > 0 ? (this.totalWins / this.totalTrades * 100) : 0;
                document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';
                document.getElementById('winRate').className = `text-xl font-bold ${winRate >= 50 ? 'text-green-400' : 'text-red-400'}`;

                document.getElementById('totalPnL').textContent = `$${this.totalPnL.toFixed(2)}`;
                document.getElementById('totalPnL').className = `text-2xl font-bold ${this.totalPnL >= 0 ? 'text-green-400' : 'text-red-400'}`;

                document.getElementById('currentStake').textContent = `$${this.currentStake.toFixed(2)}`;

                // Update learning metrics
                const entropy = this.statisticalEngine.calculateEntropy(this.asset);
                document.getElementById('marketEntropy').textContent = (entropy * 100).toFixed(1) + '%';

                const neuralMetrics = this.neuralEngine.getPerformanceMetrics();
                document.getElementById('neuralAccuracy').textContent = (neuralMetrics.accuracy * 100).toFixed(1) + '%';
            }

            updateModelWeightsUI() {
                const weights = this.ensembleDecisionMaker.modelWeights;
                const container = document.getElementById('modelWeights');

                const colors = {
                    statistical: 'bg-orange-500',
                    pattern: 'bg-purple-500',
                    neural: 'bg-blue-500',
                    streak: 'bg-green-500'
                };

                container.innerHTML = Object.entries(weights).map(([model, weight]) => {
                    const pct = (weight * 100).toFixed(0);
                    return `
                    <div class="flex justify-between items-center">
                        <span class="text-gray-400 capitalize">${model}</span>
                        <div class="flex items-center gap-2">
                            <div class="w-20 bg-gray-700 rounded-full h-2">
                                <div class="${colors[model]} h-2 rounded-full" style="width: ${pct}%"></div>
                            </div>
                            <span class="text-sm w-10">${pct}%</span>
                        </div>
                    </div>
                `;
                }).join('');
            }

            addTradeToHistory(won, profit, predicted, actual) {
                const container = document.getElementById('tradeHistory');

                if (this.tradeHistory.length === 0) {
                    container.innerHTML = '';
                }

                this.tradeHistory.unshift({ won, profit, predicted, actual, time: new Date() });
                if (this.tradeHistory.length > 50) {
                    this.tradeHistory.pop();
                }

                document.getElementById('tradeCount').textContent = this.tradeHistory.length;

                const tradeHtml = `
                <div class="glass rounded-lg p-3 ${won ? 'trade-win' : 'trade-loss'}">
                    <div class="flex justify-between items-center">
                        <div class="flex items-center gap-2">
                            <span class="text-lg">${won ? '‚úÖ' : '‚ùå'}</span>
                            <span>Differ from ${predicted}</span>
                            <span class="text-gray-500">‚Üí</span>
                            <span>Actual: ${actual}</span>
                        </div>
                        <span class="${won ? 'text-green-400' : 'text-red-400'} font-bold">
                            ${won ? '+' : ''}$${profit.toFixed(2)}
                        </span>
                    </div>
                </div>
            `;

                container.insertAdjacentHTML('afterbegin', tradeHtml);

                // Keep only last 50 in DOM
                while (container.children.length > 50) {
                    container.removeChild(container.lastChild);
                }
            }

            updateConnectionStatus(connected) {
                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');

                if (connected) {
                    dot.className = 'w-2 h-2 rounded-full bg-green-500 pulse-green';
                    text.textContent = 'Connected';
                } else {
                    dot.className = 'w-2 h-2 rounded-full bg-red-500';
                    text.textContent = 'Disconnected';
                }
            }

            updateBalance() {
                document.getElementById('balanceDisplay').textContent = `$${this.balance.toFixed(2)}`;
            }

            log(message, type = 'info') {
                const container = document.getElementById('activityLog');
                const time = new Date().toLocaleTimeString();

                const colors = {
                    info: 'text-gray-300',
                    success: 'text-green-400',
                    error: 'text-red-400',
                    warning: 'text-yellow-400'
                };

                const logHtml = `
                <div class="${colors[type]}">
                    <span class="text-gray-500">[${time}]</span> ${message}
                </div>
            `;

                container.insertAdjacentHTML('afterbegin', logHtml);

                while (container.children.length > 50) {
                    container.removeChild(container.lastChild);
                }

                console.log(`[${time}] ${message}`);
            }

            // State Management
            saveState() {
                const state = {
                    statisticalEngine: this.statisticalEngine.exportState(),
                    patternEngine: this.patternEngine.exportState(),
                    neuralEngine: this.neuralEngine.exportWeights(),
                    ensembleDecisionMaker: this.ensembleDecisionMaker.exportState(),
                    observationCount: this.observationCount,
                    totalTrades: this.totalTrades,
                    totalWins: this.totalWins,
                    totalLosses: this.totalLosses,
                    totalPnL: this.totalPnL,
                    tradeHistory: this.tradeHistory.slice(0, 100)
                };

                localStorage.setItem('digitDifferBotState', JSON.stringify(state));
            }

            loadState() {
                try {
                    const saved = localStorage.getItem('digitDifferBotState');
                    if (saved) {
                        const state = JSON.parse(saved);

                        this.statisticalEngine.importState(state.statisticalEngine || {});
                        this.patternEngine.importState(state.patternEngine || {});
                        this.neuralEngine.importWeights(state.neuralEngine || {});
                        this.ensembleDecisionMaker.importState(state.ensembleDecisionMaker || {});

                        this.observationCount = state.observationCount || 0;
                        this.totalTrades = state.totalTrades || 0;
                        this.totalWins = state.totalWins || 0;
                        this.totalLosses = state.totalLosses || 0;
                        this.totalPnL = state.totalPnL || 0;
                        this.tradeHistory = state.tradeHistory || [];

                        if (this.observationCount >= this.config.learningThreshold) {
                            this.learningMode = false;
                        }

                        console.log('State loaded from localStorage');
                    }
                } catch (e) {
                    console.error('Error loading state:', e);
                }
            }

            clearState() {
                localStorage.removeItem('digitDifferBotState');
                location.reload();
            }

            // Bot Control
            start() {
                this.token = document.getElementById('apiToken').value.trim();
                if (!this.token) {
                    this.log('Please enter your API token', 'error');
                    return;
                }

                this.asset = document.getElementById('assetSelect').value;
                this.initialStake = parseFloat(document.getElementById('stakeInput').value) || 1;
                this.currentStake = this.initialStake;
                this.config.tickDuration = parseInt(document.getElementById('durationSelect').value) || 1;
                this.config.stopLoss = parseFloat(document.getElementById('stopLoss').value) || 10;
                this.config.takeProfit = parseFloat(document.getElementById('takeProfit').value) || 5;
                this.config.minConfidence = parseFloat(document.getElementById('minConfidence').value) || 0.12;
                this.ensembleDecisionMaker.confidenceThreshold = this.config.minConfidence;

                // Martingale settings
                this.config.multiplier = parseFloat(document.getElementById('martingaleMultiplier').value) || 2.2;
                this.config.martingaleSteps = parseInt(document.getElementById('martingaleSteps').value) || 5;
                this.config.resetAfterMax = document.getElementById('resetAfterMax').value || 'reset';

                // Reset martingale state
                this.martingaleStep = 0;
                this.martingaleHistory = [];

                // Update UI
                this.updateMartingaleUI();

                this.isRunning = true;
                this.connect();

                document.getElementById('startBtn').textContent = '‚èπ Stop Bot';
                document.getElementById('startBtn').className = 'flex-1 bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white font-semibold py-2 px-6 rounded-lg transition-all';

                this.log(`Bot started | Martingale: ${this.config.multiplier}x, ${this.config.martingaleSteps} steps, ${this.config.resetAfterMax}`, 'success');
            }

            stop() {
                this.isRunning = false;
                this.disconnect();

                document.getElementById('startBtn').textContent = '‚ñ∂ Start Bot';
                document.getElementById('startBtn').className = 'flex-1 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-semibold py-2 px-6 rounded-lg transition-all';

                this.log('Bot stopped');
                this.saveState();
            }

            toggle() {
                if (this.isRunning) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        // ============================================================================
        // GLOBAL INSTANCE & HANDLERS
        // ============================================================================
        const bot = new DigitDifferBot();

        function toggleBot() {
            bot.toggle();
        }

        function clearData() {
            if (confirm('Are you sure you want to clear all learning data? This cannot be undone.')) {
                bot.clearState();
            }
        }

        // Save/Load User Settings Functions
        function saveSettings() {
            const settings = {
                apiToken: document.getElementById('apiToken').value,
                asset: document.getElementById('assetSelect').value,
                stake: document.getElementById('stakeInput').value,
                tickDuration: document.getElementById('durationSelect').value,
                stopLoss: document.getElementById('stopLoss').value,
                takeProfit: document.getElementById('takeProfit').value,
                minConfidence: document.getElementById('minConfidence').value,
                martingaleMultiplier: document.getElementById('martingaleMultiplier').value,
                martingaleSteps: document.getElementById('martingaleSteps').value,
                resetAfterMax: document.getElementById('resetAfterMax').value,
                savedAt: new Date().toISOString()
            };

            localStorage.setItem('digitDifferBotSettings', JSON.stringify(settings));

            // Show success notification
            bot.log('‚úÖ Settings saved successfully!', 'success');

            // Visual feedback
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.innerHTML = '‚úì';
            btn.classList.add('bg-green-600');
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove('bg-green-600');
            }, 1500);
        }

        function loadSettings() {
            try {
                const saved = localStorage.getItem('digitDifferBotSettings');
                if (!saved) {
                    bot.log('‚ö†Ô∏è No saved settings found.', 'warning');
                    return;
                }

                const settings = JSON.parse(saved);

                // Apply settings to form fields
                if (settings.apiToken) document.getElementById('apiToken').value = settings.apiToken;
                if (settings.asset) document.getElementById('assetSelect').value = settings.asset;
                if (settings.stake) document.getElementById('stakeInput').value = settings.stake;
                if (settings.tickDuration) document.getElementById('durationSelect').value = settings.tickDuration;
                if (settings.stopLoss) document.getElementById('stopLoss').value = settings.stopLoss;
                if (settings.takeProfit) document.getElementById('takeProfit').value = settings.takeProfit;
                if (settings.minConfidence) document.getElementById('minConfidence').value = settings.minConfidence;
                if (settings.martingaleMultiplier) document.getElementById('martingaleMultiplier').value = settings.martingaleMultiplier;
                if (settings.martingaleSteps) document.getElementById('martingaleSteps').value = settings.martingaleSteps;
                if (settings.resetAfterMax) document.getElementById('resetAfterMax').value = settings.resetAfterMax;

                // Update martingale UI display
                document.getElementById('maxMartingaleSteps').textContent = settings.martingaleSteps || '5';

                const savedDate = settings.savedAt ? new Date(settings.savedAt).toLocaleString() : 'Unknown';
                bot.log(`üìÇ Settings loaded (saved: ${savedDate})`, 'success');

                // Visual feedback
                const btn = event.target;
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úì';
                btn.classList.add('bg-green-600');
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('bg-green-600');
                }, 1500);

            } catch (e) {
                console.error('Error loading settings:', e);
                bot.log('‚ùå Error loading settings', 'error');
            }
        }

        // Initialize UI on load
        document.addEventListener('DOMContentLoaded', () => {
            bot.updateStats();
            bot.updateLearningProgress();

            // Restore trade history UI
            if (bot.tradeHistory.length > 0) {
                const container = document.getElementById('tradeHistory');
                container.innerHTML = '';
                bot.tradeHistory.forEach(trade => {
                    bot.addTradeToHistory(trade.won, trade.profit, trade.predicted, trade.actual);
                });
            }
        });
    </script>
</body>

</html>